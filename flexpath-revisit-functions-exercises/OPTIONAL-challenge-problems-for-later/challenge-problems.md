
### This list is NOT REQUIRED for the Flex Tech course.

It is an optional list of problems for students that want to continue to get 
comfortable using JavaScript as a language to solve problems.

By completing the lesson modules before this one, you now have the baseline
skills to start interacting with Data Structure & Algorithm questions.

These questions are a great way to get more comfortable with a given programming
language and start to learn common data structures that can be really beneficial 
when implementing efficient solutions for hard problems in your work as a 
Software Developer.

LeetCode is the most popular site for working on these types of questions.

Here is a list of 50 easy and medium difficulty LeetCode problems that cover 
the JavaScript concepts we've covered so far, ordered from 
least difficult to most difficult.

To find these questions, just google 'LeetCode Problem [problem #]'.

Once again, this list is OPTIONAL. You will NOT be graded on any of these
and our apprenticeship interviews are NOT centered around answering
these kinds of questions in a live setting.

If you choose to work through this list, do a LITLE BIT each day (15-20 min) 
as you put your main focus into finishing the Flex Tech course.

You can also ignore this list now and come back to it once you finish the 
Flex Tech course. That is COMPLETELY ok! 

We just wanted to provide you with a jumping off point for starting to 
engage with DS & A questions.

---

1. **Two Sum** - Easy  
    _Problem #1_  
    _Concepts:_ Function declarations, variables, arrays, loops.
    
2. **Reverse String** - Easy  
    _Problem #344_  
    _Concepts:_ Function expressions, array manipulation, loops.
    
3. **Palindrome Number** - Easy  
    _Problem #9_  
    _Concepts:_ Function declarations, conditional logic.
    
4. **Fizz Buzz** - Easy  
    _Problem #412_  
    _Concepts:_ Conditional statements, loops, modulo operator.
    
5. **Valid Parentheses** - Easy  
    _Problem #20_  
    _Concepts:_ Stack usage, function expressions.
    
6. **Merge Two Sorted Lists** - Easy  
    _Problem #21_  
    _Concepts:_ Recursion, linked lists.
    
7. **Remove Duplicates from Sorted Array** - Easy  
    _Problem #26_  
    _Concepts:_ Arrays, loops, in-place modification.
    
8. **Implement strStr()** - Easy  
    _Problem #28_  
    _Concepts:_ String manipulation, loops.
    
9. **Maximum Subarray** - Easy  
    _Problem #53_  
    _Concepts:_ Arrays, loops, variables.
    
10. **Plus One** - Easy  
    _Problem #66_  
    _Concepts:_ Arrays, loops, handling carry-over.
    
11. **Climbing Stairs** - Easy  
    _Problem #70_  
    _Concepts:_ Recursion, dynamic programming basics.
    
12. **Best Time to Buy and Sell Stock** - Easy  
    _Problem #121_  
    _Concepts:_ Arrays, loops.
    
13. **Single Number** - Easy  
    _Problem #136_  
    _Concepts:_ XOR operator, arrays.
    
14. **Linked List Cycle** - Easy  
    _Problem #141_  
    _Concepts:_ Linked lists, two-pointer technique.
    
15. **Min Stack** - Easy  
    _Problem #155_  
    _Concepts:_ Stack implementation, OOP in JavaScript.
    
16. **Intersection of Two Linked Lists** - Easy  
    _Problem #160_  
    _Concepts:_ Linked lists, function expressions.
    
17. **Majority Element** - Easy  
    _Problem #169_  
    _Concepts:_ Arrays, hash maps.
    
18. **Excel Sheet Column Number** - Easy  
    _Problem #171_  
    _Concepts:_ Loops, string manipulation.
    
19. **Reverse Linked List** - Easy  
    _Problem #206_  
    _Concepts:_ Recursion, linked lists.
    
20. **Contains Duplicate** - Easy  
    _Problem #217_  
    _Concepts:_ Arrays, Sets.
    
21. **Implement Queue using Stacks** - Easy  
    _Problem #232_  
    _Concepts:_ Stack and queue implementation, function scope.
    
22. **Valid Anagram** - Easy  
    _Problem #242_  
    _Concepts:_ Strings, arrays, sorting.
    
23. **Power of Three** - Easy  
    _Problem #326_  
    _Concepts:_ Recursion, loops.
    
24. **Move Zeroes** - Easy  
    _Problem #283_  
    _Concepts:_ Arrays, in-place manipulation.
    
25. **First Unique Character in a String** - Easy  
    _Problem #387_  
    _Concepts:_ Strings, hash maps.
    
26. **Find All Numbers Disappeared in an Array** - Easy  
    _Problem #448_  
    _Concepts:_ Arrays, in-place modification.
    
27. **Add Strings** - Easy  
    _Problem #415_  
    _Concepts:_ Strings, loops, handling carry-over.
    
28. **Intersection of Two Arrays II** - Easy  
    _Problem #350_  
    _Concepts:_ Arrays, hash maps.
    
29. **Keyboard Row** - Easy  
    _Problem #500_  
    _Concepts:_ Strings, arrays, sets.
    
30. **Subdomain Visit Count** - Medium  
    _Problem #811_  
    _Concepts:_ Strings, hash maps.
    
31. **Binary Tree Inorder Traversal** - Medium  
    _Problem #94_  
    _Concepts:_ Recursion, tree traversal.
    
32. **Kth Largest Element in an Array** - Medium  
    _Problem #215_  
    _Concepts:_ Arrays, sorting, heaps.
    
33. **Find the Duplicate Number** - Medium  
    _Problem #287_  
    _Concepts:_ Arrays, two-pointer technique.
    
34. **Product of Array Except Self** - Medium  
    _Problem #238_  
    _Concepts:_ Arrays, prefix products.
    
35. **Group Anagrams** - Medium  
    _Problem #49_  
    _Concepts:_ Strings, arrays, hash maps.
    
36. **Valid Sudoku** - Medium  
    _Problem #36_  
    _Concepts:_ Arrays, hash sets.
    
37. **Top K Frequent Elements** - Medium  
    _Problem #347_  
    _Concepts:_ Hash maps, heaps.
    
38. **Letter Combinations of a Phone Number** - Medium  
    _Problem #17_  
    _Concepts:_ Recursion, backtracking.
    
39. **Generate Parentheses** - Medium  
    _Problem #22_  
    _Concepts:_ Recursion, backtracking.
    
40. **Combination Sum** - Medium  
    _Problem #39_  
    _Concepts:_ Recursion, backtracking.
    
41. **Permutations** - Medium  
    _Problem #46_  
    _Concepts:_ Recursion, backtracking.
    
42. **Subsets** - Medium  
    _Problem #78_  
    _Concepts:_ Recursion, backtracking, bit manipulation.
    
43. **Binary Search Tree Iterator** - Medium  
    _Problem #173_  
    _Concepts:_ Stacks, trees, iterator pattern.
    
44. **Serialize and Deserialize Binary Tree** - Medium  
    _Problem #297_  
    _Concepts:_ Trees, recursion, object-oriented programming.
    
45. **Implement Trie (Prefix Tree)** - Medium  
    _Problem #208_  
    _Concepts:_ Trees, recursion, objects.
    
46. **Course Schedule** - Medium  
    _Problem #207_  
    _Concepts:_ Graphs, recursion, DFS.
    
47. **LRU Cache** - Medium  
    _Problem #146_  
    _Concepts:_ Hash maps, doubly linked lists, OOP in JavaScript.
    
48. **Clone Graph** - Medium  
    _Problem #133_  
    _Concepts:_ Graph traversal, recursion, hash maps.
    
49. **Word Ladder** - Medium  
    _Problem #127_  
    _Concepts:_ BFS, hash sets, strings.
    
50. **Alien Dictionary** - Medium  
    _Problem #269_  
    _Concepts:_ Topological sort, graphs, recursion.
    

---

Each problem progressively increases in difficulty and covers 
various JavaScript concepts from your list. 

They provide practical applications of:

- **Function Concepts:**
    
    - Declarations vs. expressions
    - Arrow functions
    - Recursion
    - IIFE
    - Function parameters and arguments
    - Default parameters
    - Rest parameters
    - Callbacks and higher-order functions
    - Function scope and closures
    - `this` keyword behavior
- **Looping Constructs:**
    
    - For loops (classic, for-of, for-in)
    - While and do-while loops
    - ForEach loops
    - Advanced iteration methods (`map`, `filter`, `reduce`, etc.)
- **Branching Constructs:**
    
    - If-else statements
    - Switch statements
    - Ternary operators
    - Handling falsy and truthy values
    - Nullish coalescing
- **Objects and Arrays:**
    
    - Object creation and manipulation
    - Prototypes and inheritance
    - Array methods and manipulation
    - Shallow vs. deep copying
    - Memory management considerations

By working through these problems, you'll strengthen your understanding of 
the JavaScript concepts listed above and gain practical experience in 
applying them to solve algorithmic challenges.